\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `dgdecomp'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Das Gupta Decomposition on Multiplicative Factors}
\item[Version]\AsIs{1.1.0}
\item[Description]\AsIs{Takes any P number of factors, and decomposes them into additive factors.}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{TRUE}
\item[URL]\AsIs{}\url{https://github.com/sadatnfs/dgdecomp}\AsIs{}
\item[BugReports]\AsIs{}\url{https://github.com/sadatnfs/dgdecomp/issues}\AsIs{}
\item[NeedsCompilation]\AsIs{yes}
\item[Author]\AsIs{Nafis Sadat [aut]}
\item[Maintainer]\AsIs{Nafis Sadat }\email{sadatnfs@gmail.com}\AsIs{}
\item[LinkingTo]\AsIs{Rcpp, RcppArmadillo}
\item[Depends]\AsIs{data.table, Rcpp, RcppArmadillo}
\item[Suggests]\AsIs{assertthat, testthat, foreach, data.table, matrixStats, MASS,
knitr, rmarkdown}
\item[VignetteBuilder]\AsIs{knitr}
\item[License]\AsIs{MIT + file LICENSE}
\item[RoxygenNote]\AsIs{6.1.1}
\item[RemoteType]\AsIs{github}
\item[RemoteHost]\AsIs{api.github.com}
\item[RemoteRepo]\AsIs{dgdecomp}
\item[RemoteUsername]\AsIs{sadatnfs}
\item[RemoteRef]\AsIs{master}
\item[RemoteSha]\AsIs{545f88d3b3677b192c3fca1b5a4cf0c39d2bef9a}
\item[RemoteSubdir]\AsIs{dgdecomp}
\item[GithubRepo]\AsIs{dgdecomp}
\item[GithubUsername]\AsIs{sadatnfs}
\item[GithubRef]\AsIs{master}
\item[GithubSHA1]\AsIs{545f88d3b3677b192c3fca1b5a4cf0c39d2bef9a}
\item[GithubSubdir]\AsIs{dgdecomp}
\item[Archs]\AsIs{i386, x64}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{dgdecomp-package}{Das Gupta Decomposition on Multiplicative Factors}{dgdecomp.Rdash.package}
\aliasA{dgdecomp}{dgdecomp-package}{dgdecomp}
\keyword{package}{dgdecomp-package}
%
\begin{Description}\relax
Takes any P number of factors, and decomposes them into additive factors.
\end{Description}
%
\begin{Details}\relax
The DESCRIPTION file: 
\Tabular{ll}{
Package: & dgdecomp\\{}
Type: & Package\\{}
Title: & Das Gupta Decomposition on Multiplicative Factors\\{}
Version: & 1.1.0\\{}
Authors@R: & person("Nafis", "Sadat", email = "sadatnfs@gmail.com",
  role = c("aut", "cre"))\\{}
Description: & Takes any P number of factors, and decomposes them into additive factors.\\{}
Encoding: & UTF-8\\{}
LazyData: & TRUE\\{}
URL: & https://github.com/sadatnfs/dgdecomp\\{}
BugReports: & https://github.com/sadatnfs/dgdecomp/issues\\{}
NeedsCompilation: & yes\\{}
Author: & Nafis Sadat [aut]\\{}
Maintainer: & Nafis Sadat <sadatnfs@gmail.com>\\{}
LinkingTo: & Rcpp,
RcppArmadillo\\{}
Depends: & data.table,
Rcpp,
RcppArmadillo\\{}
Suggests: & assertthat,
testthat,
foreach,
data.table,
matrixStats,
MASS,
knitr,
rmarkdown\\{}
VignetteBuilder: & knitr\\{}
License: & MIT + file LICENSE\\{}
RoxygenNote: & 6.1.1\\{}
RemoteType: & github\\{}
RemoteHost: & api.github.com\\{}
RemoteRepo: & dgdecomp\\{}
RemoteUsername: & sadatnfs\\{}
RemoteRef: & master\\{}
RemoteSha: & 545f88d3b3677b192c3fca1b5a4cf0c39d2bef9a\\{}
RemoteSubdir: & dgdecomp\\{}
GithubRepo: & dgdecomp\\{}
GithubUsername: & sadatnfs\\{}
GithubRef: & master\\{}
GithubSHA1: & 545f88d3b3677b192c3fca1b5a4cf0c39d2bef9a\\{}
GithubSubdir: & dgdecomp\\{}
}

Index of help topics:
\begin{alltt}
Decomp_Factors          Compute the marginal decomposition effects from
                        given input
Decomp_on_DT            Apply DG Decomposition to data.table columns
Func_Create_Combn       Compute the combination of all positions of the
                        given factor segmented into two pieces
Func_Cross              Compute the combination of all the elements of
                        the given vectors corresponding to the given
                        sizes (using Func_Create_Combn)
Func_Dem                Compute the denomiator of the inner sums in the
                        DG Decomposition
Func_Inner              Compute the fraction for the inner sum in the
                        DG Decomposition where all the params gets
                        passed to Func_Num() and Func_Den()
Func_Inner_Sum          Sum over all inner sums for the DG
                        Decomposition
Func_Num                Compute the numerator of the inner sums in the
                        DG Decomposition
dgdecomp-package        Das Gupta Decomposition on Multiplicative
                        Factors
simulate_decomp_data    Simulate simple random decomp data for P
                        factors such that the product of P factors
                        equal a measure for 2 time periods
simulate_decomp_data_fullmat
                        Simulate grouped data for decomp analysis (T by
                        IDI by factors)
\end{alltt}


This section should provide a more detailed overview of how to use the
package, including the most important functions.
\end{Details}
%
\begin{Author}\relax
Nafis Sadat [aut]

Maintainer: Nafis Sadat <sadatnfs@gmail.com>
\end{Author}
%
\begin{References}\relax
This optional section can contain literature or other references for
background information.
\end{References}
%
\begin{SeeAlso}\relax
Optional links to other man pages
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  ## Optional simple examples of the most important functions
  ## Use \dontrun{} around code to be shown but not executed
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{Decomp\_Factors}{Compute the marginal decomposition effects from given input}{Decomp.Rul.Factors}
\aliasA{Decomp\_Factors\_Matx}{Decomp\_Factors}{Decomp.Rul.Factors.Rul.Matx}
%
\begin{Description}\relax
\code{Decomp\_Factor\_Matx()} can be used if the input has
multiple rows of data to decompose, whereas \code{Decomp\_Factor()} only
takes in vectors as inputs.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Decomp_Factors(vec_x, vec_y, return_dt = TRUE, equality_check = TRUE,
  ...)

Decomp_Factors_Matx(mat_x, mat_y, return_dt = TRUE, use_cpp = TRUE,
  parallel = 1, equality_check = TRUE, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vec\_x}] First input vector (represents t-1)

\item[\code{vec\_y}] Second input vector (represents t)

\item[\code{return\_dt}] A boolean on whether to return a data.table or a vector

\item[\code{equality\_check}] Check whether the decomp values align with inputs.
Default: TRUE. Highly recommended to set to TRUE.

\item[\code{...}] extra parameters to be passed to \code{all.equal()}, for e.g.
the tolerance.

\item[\code{mat\_x}] First input matrix (only for \code{Decomp\_Factor\_Matx()})

\item[\code{mat\_y}] Second input matrix (only for \code{Decomp\_Factor\_Matx()})

\item[\code{use\_cpp}] A boolean on whether to use the C++ compiled code or not.
Default: TRUE

\item[\code{parallel}] Number of threads. Default : 1
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data.table or vector of decomposed effects for each factors,
which is already multiplied by the change values
\end{Value}
\inputencoding{utf8}
\HeaderA{Decomp\_on\_DT}{Apply DG Decomposition to data.table columns}{Decomp.Rul.on.Rul.DT}
%
\begin{Description}\relax
Apply DG Decomposition to data.table columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Decomp_on_DT(input_data, factor_names, time_col, bycol, use_cpp = TRUE,
  parallel = 1, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{input\_data}] A data.table with the factors, which must already
be sorted

\item[\code{factor\_names}] A vector of column names for the factor

\item[\code{time\_col}] A string for the column name

\item[\code{bycol}] The 'by' slicer which must make sure that the data is
reduced to just 2 rows per group after slicing

\item[\code{use\_cpp}] A boolean on whether to use the C++ compiled code for the
factor for-loop or not (passes to Decomp\_Factor\_Matx()). Default: TRUE

\item[\code{parallel}] Number of threads. Default : 1

\item[\code{...}] extra parameters to be passed through \code{Decomp\_Factors()}
to \code{all.equal()}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data.table of the same size as input, but instead with
the additive decomposition results (first row will be NA as being the
starting period)
\end{Value}
\inputencoding{utf8}
\HeaderA{Func\_Create\_Combn}{Compute the combination of all positions of the given factor segmented into two pieces}{Func.Rul.Create.Rul.Combn}
%
\begin{Description}\relax
Compute the combination of all positions of the given factor
segmented into two pieces
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Func_Create_Combn(Pfac, size1, size2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Pfac}] Number of factors minus 1

\item[\code{size1}] Number of elements to take from vec\_x

\item[\code{size2}] Number of elements to take from vec\_y
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of positions made from the unique combinations
of size1 and size2
\end{Value}
\inputencoding{utf8}
\HeaderA{Func\_Cross}{Compute the combination of all the elements of the given vectors corresponding to the given sizes (using Func\_Create\_Combn)}{Func.Rul.Cross}
\aliasA{Func\_Cross\_Matx}{Func\_Cross}{Func.Rul.Cross.Rul.Matx}
%
\begin{Description}\relax
Compute the combination of all the elements of the given vectors
corresponding to the given sizes (using Func\_Create\_Combn)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Func_Cross(vec_x, vec_y, size1, size2)

Func_Cross_Matx(vec_x, vec_y, size1, size2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vec\_x}] First input vector

\item[\code{vec\_y}] Second input vector

\item[\code{size1}] Number of elements to take from vec\_x

\item[\code{size2}] Number of elements to take from vec\_y
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of column products made from the unique combinations
of the *data*
\end{Value}
\inputencoding{utf8}
\HeaderA{Func\_Dem}{Compute the denomiator of the inner sums in the DG Decomposition}{Func.Rul.Dem}
%
\begin{Description}\relax
Compute the denomiator of the inner sums in the DG Decomposition
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Func_Dem(P, r)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{P}] Number of factors

\item[\code{r}] The summing indicator
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A numeric with value of \code{P * choose((P - 1), (r - 1))}
\end{Value}
\inputencoding{utf8}
\HeaderA{Func\_Inner}{Compute the fraction for the inner sum in the DG Decomposition where all the params gets passed to Func\_Num() and Func\_Den()}{Func.Rul.Inner}
\aliasA{Func\_Inner\_Matx}{Func\_Inner}{Func.Rul.Inner.Rul.Matx}
%
\begin{Description}\relax
Compute the fraction for the inner sum in the DG Decomposition
where all the params gets passed to Func\_Num() and Func\_Den()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Func_Inner(P, r, vec_x, vec_y)

Func_Inner_Matx(P, r, vec_x, vec_y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{P}] Number of factors

\item[\code{r}] The summing indicator

\item[\code{vec\_x}] First input vector

\item[\code{vec\_y}] Second input vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The fraction of the results of Func\_Num() and Func\_Den
\end{Value}
\inputencoding{utf8}
\HeaderA{Func\_Inner\_Sum}{Sum over all inner sums for the DG Decomposition}{Func.Rul.Inner.Rul.Sum}
\aliasA{Func\_Inner\_Sum\_Matx}{Func\_Inner\_Sum}{Func.Rul.Inner.Rul.Sum.Rul.Matx}
%
\begin{Description}\relax
Sum over all inner sums for the DG Decomposition
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Func_Inner_Sum(P, vec_x, vec_y)

Func_Inner_Sum_Matx(P, vec_x, vec_y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{P}] Number of factors

\item[\code{vec\_x}] First input vector

\item[\code{vec\_y}] Second input vector

\item[\code{threads}] Number of OpenMP threads to use. Default: 1
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A numeric value with the full inner sum for the given effect
\end{Value}
\inputencoding{utf8}
\HeaderA{Func\_Num}{Compute the numerator of the inner sums in the DG Decomposition}{Func.Rul.Num}
\aliasA{Func\_Num\_Matx}{Func\_Num}{Func.Rul.Num.Rul.Matx}
%
\begin{Description}\relax
Compute the numerator of the inner sums in the DG Decomposition
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Func_Num(P, r, vec_x, vec_y)

Func_Num_Matx(P, r, vec_x, vec_y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{P}] Number of factors

\item[\code{r}] The summing indicator

\item[\code{vec\_x}] First input vector

\item[\code{vec\_y}] Second input vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A single numeric from the sums of Func\_Cross()
\end{Value}
\inputencoding{utf8}
\HeaderA{simulate\_decomp\_data}{Simulate simple random decomp data for P factors such that the product of P factors equal a measure for 2 time periods}{simulate.Rul.decomp.Rul.data}
%
\begin{Description}\relax
Simulate simple random decomp data for P factors such that the
product of P factors equal a measure for 2 time periods
\end{Description}
%
\begin{Usage}
\begin{verbatim}
simulate_decomp_data(num_fac)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{num\_fac}] Number of factors to simulate
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A named list with the vector of P factors for 2 time periods,
and 2 numeric measures for each time period, which are just the
product of each of the two factor vectors
\end{Value}
\inputencoding{utf8}
\HeaderA{simulate\_decomp\_data\_fullmat}{Simulate grouped data for decomp analysis (T by IDI by factors)}{simulate.Rul.decomp.Rul.data.Rul.fullmat}
%
\begin{Description}\relax
Simulate grouped data for decomp analysis (T by IDI by factors)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
simulate_decomp_data_fullmat(T_term, num_factors, id_grps)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{T\_term}] Number of time periods

\item[\code{num\_factors}] Number of factors (gets slower for large numbers)

\item[\code{id\_grps}] Number of groups
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data.table with T\_term*id\_grps rows and num\_factors+1 columns
where X\_1, ... , X\_p are the factors, and Y is the rowwise product of the
factors
\end{Value}
\printindex{}
\end{document}
